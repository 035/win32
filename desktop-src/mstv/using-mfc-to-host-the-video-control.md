---
title: Using MFC to Host the Video Control
description: Using MFC to Host the Video Control
ms.assetid: 6a360368-e5e6-4fee-a455-17553a222136
ms.technology: desktop
ms.prod: windows
ms.author: windowssdkdev
ms.topic: article
ms.date: 05/31/2018
---

# Using MFC to Host the Video Control

This topic applies to Windows XP or later.

> [!Note]  
> This topic applies to MFC version 6.0, using Microsoft® Visual C++® version 6.0.

 

This article shows how to create an MFC application that hosts the Video Control. To set up the project, perform the following steps.

1.  Create a new project using the MFC App Wizard. A dialog-based application without the document-view architecture is probably simplest, but that is up to you. Check the boxes for Active X Control and Automation support.
2.  Link to strmiids.lib.
3.  Add wrapper classes for Video Control and its related interfaces, as follows:
    1.  From the **Project** menu, select **Add to Project** and **Components and Controls**.
    2.  Open the **Registered ActiveX Controls** folder.
    3.  Select **MS TV Video Control** and click **Insert**.
    4.  Accept all the wrapper classes that Class Wizard proposes to create. For the CMSVidCtl class, it is a good idea to change the default file names from msvidctl.\* to something else, such as msvidctl\_1.\*, to avoid confusion with the DirectShow include files with the same name.
4.  In Resource View, open the dialog or window form. Add the Video Control to the form by dragging its icon from the **Controls** toolbar.
5.  Add a data member for the control, as follows:
    1.  Right click the control and select **Class Wizard**.
    2.  Select the **Member Variables** tab and click **Add Variable**.
    3.  Type a variable name for the data member.
6.  Include the following header files:

    -   `tuner.h`
    -   `msvidctl.h`

    Tuner.h defines the Tuning Model interfaces, and msvidctl.h defines the Video Control interface. You must include msvidctl.h because MFC does not provide wrapper classes for certain derived classes that you will need to use.

The DLL for the Video Control, msvidctl.dll, contains two type libraries, but MFC does not create wrapper classes for all of the objects in both libraries. Therefore, you must use a combination of techniques to access and control the various Video Control and Tuning Model objects. The following code snippets illustrate these techniques.

## Create an instance of an MFC-generated wrapper class

All the COM calls are hidden. Notice that the method names in the wrapper classes are slightly different from the names generated by MIDL in the original header files.


```C++
CMSVidVideoRenderer myRenderer = m_VidCtl.GetActiveRenderer();
CRect sourceRect = myRenderer.GetSourceSize();
```



## Create an instance of a Tuning Model COM object

Because MFC does not create any wrapper classes for the Tuning Model objects, you must create and access them using the native COM methods such as **CoCreateInstance** and **QueryInterface**.


```C++
HRESULT hr;
CComPtr<ITuningSpaceContainer> pTuningSpaceContainer;  
hr = CoCreateInstance(CLSID_SystemTuningSpaces,
    NULL, 
    CLSCTX_INPROC_SERVER, 
    IID_ITuningSpaceContainer,
    reinterpret_cast<void**> (&amp;pTuningSpaceContainer));
if(FAILED(hr))
{
    AfxMessageBox("Failed to create system tuning spaces object");
    return false;
}
long count = 0;
hr = pTuningSpaceContainer->get_Count(&amp;count);
if(FAILED(hr))
{
    AfxMessageBox("Failed to get count");
    return false;
}

```



## Obtain a derived interface from a wrapper class

MFC does not create a wrapper class for some derived interfaces, such as **IMSVidTuner**. To get a pointer to these interfaces, to use the **m\_lpDispatch** member of the wrapper class, which is an **IDispatch** pointer, to call **QueryInterface**.


```C++
CMSVidInputDevice inputDevice = m_VidCtl.GetInputActive();
if (inputDevice.m_lpDispatch) 
{   
    // We have an active input.
    CComPtr<IMSVidTuner> myTuner;
    inputDevice.m_lpDispatch->QueryInterface(
        __uuidof(IMSVidTuner),
        reinterpret_cast<void**> &amp;myTuner);
    if (FAILED(hr))
    {
        AfxMessageBox("Failed to QI for tuner");
        return;
    }
    
    // Assume pATSCTR is an IATSCTuneRequest interface pointer.
    myTuner->put_Tune(pATSCTR);
}

```



 

 




